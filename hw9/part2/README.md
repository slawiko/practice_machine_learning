### t-SNE MNIST

Данные качал при помощи `sklearn.datasets.fetch_mldata`. Визуализирова только рандомные 10000 элементов из выборки, в угоду скорости. Далее осуществлял перебор параметров: `perplexity` 10, 30, 50, количество итераций 250, 500, 1000, 3000. `learning_rate(epsion)` не перебирал, использовал 500, как в примере на сайте [t-SNE](https://lvdmaaten.github.io/tsne/).

Как понятно из графиков [p=10 iterations=250](./plots/p=10_iterations=250.png), [p=30 iterations=250](./plots/p=30_iterations=250.png), [p=50 iterations=250](./plots/p=50_iterations=250.png) 250 итераций довольно мало. Притом не важно какое perplexity. Не зря это минимальное значение для t-SNE.

Далее рассмотрим каждое значение perplexity отдельно:

#### p=10

При 500 итерациях ![p=10 iterations=500](./plots/p=10_iterations=500.png) уже можно придумать какие-то зависимости. Например `4` и `9` смешались, что можно объяснить тем, что цифры часто похожи. Но больше никаких зависимостей на этой картинке я не увидел.

Здесь: ![p=10 iterations=1000](./plots/p=10_iterations=1000.png) близость `4` и `9` остается, но теперь все кластеры выделились более явно.

При 3000 итераций: ![p=10 iterations=3000](./plots/p=10_iterations=3000.png) все то же самое, только классы разделились ещё сильнее. 

Из интересного, что объяснить не смог: кластеры слегка перемещаются относительно друг друга в зависимости от количества итераций, но не глобально. То есть `5` и `3` всегда рядом, а `8` сначала была ближе к `3`, а потом сместилась и стала одинаково близко к `5` и `3`.

#### p=30

Ситуация с относительным расположением здесь такая же, как была при perplexity = 10. А вот сами кластеры стали более плотными, относительно графиков при perplexity = 10.

Например 500 итераций: ![p=10 iterations=500](./plots/p=10_iterations=500.png) ![p=30 iterations=500](./plots/p=30_iterations=500.png)

1000 итераций: ![p=10 iterations=1000](./plots/p=10_iterations=1000.png) ![p=30 iterations=1000](./plots/p=30_iterations=1000.png)

#### p=50